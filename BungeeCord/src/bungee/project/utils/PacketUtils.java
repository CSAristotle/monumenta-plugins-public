package bungee.project.utils;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.charset.StandardCharsets;

public class PacketUtils {
	/* If a packet shows up with more than 16 MB of data, something is probably wrong */
	public static int MAX_PACKET_LEN = 1024 * 1024 * 16;

	/**
	 * Encodes string array to a byte buffer, which is encoded to a single string
	 *
	 * The format of the byte buffer is:
	 * 	4-byte little-endian integer count of number of string elements
	 * 	{
	 * 		4-byte length of string bytes
	 * 		String bytes
	 * 	} * # strings
	 *
	 * 	Returns encoded String if successful, otherwise throws an Exception
	 */
	public static String encodeStrings(String in[]) throws Exception {
		byte[][] strBytes = new byte[in.length][];

		// Counter for how many bytes will need to be written
		// First four bytes are how many elements are in the array
		int numBytes = 4;

		// Convert all input strings to byte arrays
		// Add up the lengths of the byte arrays
		for (int i = 0; i < in.length; i++) {
			strBytes[i] = in[i].getBytes(StandardCharsets.ISO_8859_1);
			numBytes += 4 + strBytes[i].length;
		}

		// Allocate space for one flat byte array result
		byte[] result = new byte[numBytes];

		// Track how many bytes have been written to the result buffer so far
		int numBytesWritten = 0;

		// Write number of elements to the array
		byte[] elementCountBytes = ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN).putInt(in.length).array();
		System.arraycopy(elementCountBytes, 0, result, numBytesWritten, elementCountBytes.length);
		numBytesWritten += elementCountBytes.length;

		// Write bytes and lengths to the result array
		for (int i = 0; i < in.length; i++) {
			// Write length first
			byte[] lengthBytes = ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN).putInt(strBytes[i].length).array();
			System.arraycopy(lengthBytes, 0, result, numBytesWritten, lengthBytes.length);
			numBytesWritten += lengthBytes.length;

			// Write payload
			System.arraycopy(strBytes[i], 0, result, numBytesWritten, strBytes[i].length);
			numBytesWritten += strBytes[i].length;
		}

		if (numBytesWritten != numBytes) {
			throw new Exception("Length mismatch writing strings to byte array");
		}

		return new String(result, StandardCharsets.ISO_8859_1);
	}

	/**
	 * Decodes a stringified byte array (generated by encodeStrings) into an array of strings
	 */
	public static String[] decodeStrings(String encodedStr) throws Exception {
		/* Convert the encoded input string back to a byte buffer */
		byte[] encoded = encodedStr.getBytes(StandardCharsets.ISO_8859_1);

		// Bytebuffer object for reading integer lengths
		ByteBuffer buf = ByteBuffer.wrap(encoded).order(ByteOrder.LITTLE_ENDIAN);

		// Number of bytes processed so far
		int numBytesRead = 0;

		// Read number of elements
		int numElements = buf.getInt(numBytesRead);
		numBytesRead += 4;

		if (numElements <= 0) {
			throw new Exception("Byte buffer contains no entries");
		}

		if (numElements > MAX_PACKET_LEN) {
			throw new Exception("Got impossibly large numElements = " + Integer.toString((numElements)));
		}

		// Allocate strings for the payload
		String[] result = new String[numElements];

		// Read each string
		for (int i = 0; i < numElements; i++) {
			int elementLen = buf.getInt(numBytesRead);
			numBytesRead += 4;

			if (elementLen <= 0) {
				throw new Exception("Byte buffer is empty");
			}
			if (numElements > MAX_PACKET_LEN) {
				throw new Exception("Got impossibly large elementLen = " + Integer.toString((elementLen)));
			}

			result[i] = new String(encoded, numBytesRead, elementLen, StandardCharsets.ISO_8859_1);
			numBytesRead += elementLen;
		}

		if (numBytesRead != encoded.length) {
			throw new Exception("Length mismatch reading strings from byte array");
		}

		return result;
	}
}
